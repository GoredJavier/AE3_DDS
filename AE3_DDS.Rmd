---
title: "Practica 3 Data Driven Security"
output: html_document
date: "2025-01-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r carga_librerias, include=FALSE}
library(readr)
library(stringr)
library(swirl)
library(RCurl)
library(ggplot2)
library(ggpubr)
library(ggrepel)
library(RColorBrewer)
library(mltools)
library(data.table)
library(tidyr)
library(dplyr)

```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:


Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r Obtención de datos y limpieza}

df <- read.csv2("./epa-http.csv", sep=' ', header=FALSE)

colnames(df) <- c("Path","Date", "Request", "StatusCode", "Size")

df <- df %>%
  separate(Request, into = c("RequestType", "Resource", "Version"), sep = " ") %>%
  separate(Version, into = c("Protocol", "Version"), sep = "/") 

df$ResourceType <- str_extract(df$Resource, "\\.([a-zA-Z0-9]+)$") %>% 
      str_remove("^\\.")


#df$ResourceType <- mutate(
#    extension = str_extract(Resource, "\\.([a-zA-Z0-9]+)$") %>% 
#      str_remove("^\\.")
#  )

df$Date <- as.POSIXct(gsub("^\\[|\\]$", "", df$Date), format="%d:%H:%M:%S")

df$RequestType <- as.factor(df$RequestType)
df$Protocol <- as.factor(df$Protocol)
df$Version <- as.factor (df$Version)
df$StatusCode <- as.factor(df$StatusCode)
df$Size <- as.numeric(df$Size)
df$Version <- as.factor(df$Version)
df$ResourceType <- as.factor (df$ResourceType)

#Reordenamos la columan ResourceType
df <- df %>% select(1:4,ResourceType,5:ncol(df))

```

```{r Numero unico de usuarios}

#Respuestas informativas (100–199),
#Respuestas satisfactorias (200–299),
#Redirecciones (300–399),
#Errores de los clientes (400–499),
#y errores de los servidores (500–599).

#4. Se pide: Identificar el número único de usuarios que han interactuado
# directamente con el servidor de forma segregada según si los usuarios
# han tenido algún tipo de error en las distintas peticiones ofrecidas por el
# servidor.

# Clasificar usuarios
resumen_usuarios <- df %>%
  group_by(Path) %>%
  reframe(
    StatusCode = unique(as.numeric(as.character(StatusCode))[as.numeric(as.character(StatusCode)) >= 400])
  ) 

resultado_final <- resumen_usuarios %>%
  group_by(StatusCode) %>%
  reframe(
    num_usuarios = n())

```



```{r Pregunta 5}

#Analizar los distintos tipos de peticiones HTTP (GET, POST, PUT, DELETE) gestionadas por el servidor, identificando la frecuencia de cada una de estas.

# Obtener la tabla de frecuencias de la columna 'status_code'
tabla_frecuencias <- table(df$RequestType)

# Mostrar la tabla de frecuencias
print(tabla_frecuencias)

#Repetir el análisis, esta vez filtrando previamente aquellas peticiones correspondientes a recursos ofrecidos de tipo imagen.
df_imagenes <- df %>%
  filter(ResourceType %in% c("jpg", "jpeg", "png", "gif", "bmp", "svg"))

tabla_imagenes <- table(df_imagenes$RequestType)

print(tabla_imagenes)

```
```{r Pie chart frecuencia protocolos 2}
#Añadir colores si podemos

#Pregunta 6: Generar al menos 2 gráficos distintos que permitan visualizar alguna característica relevante de los datos analizados.Estos deberán representar por lo menos 1 o 2 variables diferentes del data frame. Describid el gráfico e indicad cualquier observación destacable que se pueda apreciar gracias a la representación gráfica.

df_protocols <- as.data.frame(tabla_frecuencias)
colnames(df_protocols) <- c("RequestType","Value")
df_protocols$Porcentaje <- round(df_protocols$Value/length(df$StatusCode)*100,1)

paleta <- colorRampPalette(brewer.pal(6, "Blues"))
```


```{r Pie chart frecuencia protocolos}
# Crear el gráfico de pastel
#ggplot(df_protocols, aes(x = "", y = Porcentaje, fill = RequestType)) +
#  geom_bar(stat = "identity", width = 0.9) +  
#  coord_polar(theta = "y") +  
#  labs(title = "Porcentaje según tipo de request") +
#  theme_void() + 
#  geom_text_repel(aes(label=paste0(Porcentaje,"%")), position = position_stack(vjust = 0.5)) + 
#  scale_fill_manual(values=paleta(length(df_protocols$Porcentaje)))

df$ScaledSize <- scale(df$Size)

#Creamos un boxplot
ggplot(df, aes(x = RequestType, y=ScaledSize)) +
  geom_boxplot(fill="lightblue", alpha=0.2) +
  labs(title = "Tipo de petición vs Tama\u00f1o", x="Scaled Size") +
  xlab("RequestType") + 
  theme_minimal()

ggplot(df, aes(x = RequestType, y = ScaledSize)) +
  geom_boxplot(fill = "lightblue", alpha = 0.6) +  # Ajuste de alpha para menos transparencia
  labs(title = "Tipo de petición vs Tama\u00f1o", x = "Tipo de peticin", y = "Tamao escalado") +  # Etiquetas
  theme_minimal() +  # Tema minimalista que mantiene los ejes
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Título centrado y más grande
    axis.title = element_text(size = 12, face = "bold"),  # Títulos de los ejes más grandes
    axis.text = element_text(size = 10),  # Tama\u00f1o de texto de los ejes
    panel.grid.major = element_line(color = "gray90", size = 0.5)  # Líneas de la cuadrícula más suaves
  )

# Mejorar la apariencia con cuadros alrededor de las etiquetas del eje X
ggplot(df, aes(x = RequestType, y = ScaledSize)) +
  geom_boxplot(fill = "lightblue", alpha = 0.6) +  # Ajuste de alpha para menos transparencia
  labs(title = "Tipo de peticin vs Tamao", x = "Tipo de peticin", y = "Tamaoo escalado") +  # Etiquetas
  theme_minimal() +  # Tema minimalista
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Título centrado y más grande
    axis.title = element_text(size = 12, face = "bold"),  # Títulos de los ejes más grandes
    axis.text = element_text(size = 10),  # Tamao de texto de los ejes
    panel.grid.major = element_line(color = "gray90", size = 0.5),  # Líneas de la cuadrícula más suaves
    axis.text.x = element_text(
      size = 12, 
      face = "bold", 
      color = "black", 
      angle = 45, 
      hjust = 1
    ),
    axis.ticks.x = element_line(size = 2, color = "darkblue")  # Poner un borde de color en las etiquetas
  ) +
  # Añadir rectángulos como fondo a las etiquetas del eje X
  geom_text(aes(label = RequestType), position = position_nudge(y = 0.1), size = 4, color = "black")




```

```{r pregunta 7: histograma de peticiones}

# 7. Generar un gráfico que permita visualizar el número de peticiones servidas a lo largo del tiempo.

table_TimeVsRequest <- table(df$Date, df$RequestType)
df_TimeVsRequest <- as.data.frame(table_TimeVsRequest)
colnames(df_TimeVsRequest) <- c("Time", "RequestType", "Request")
df_TimeVsRequest$Time <- as.POSIXct(df_TimeVsRequest$Time, format="%Y-%m-%d %H:%M:%S") # Se convierte la columna time en formato de fecha y hora

# Crear la gráfica
ggplot(df_TimeVsRequest, aes(x = Time)) +
  geom_histogram(binwidth = (3600), fill = "coral", color = "black") +
  scale_x_datetime(date_breaks = "2 hours", date_labels = "%Y-%m-%d %H:%M") +
  labs(title = "Histograma de Fechas por Hora",
       x = "Fecha y Hora",
       y = "Frecuencia") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
geom_text(stat = "bin", aes(label = after_stat(count)), binwidth = (3600), hjust= -0.2 , angle = 90)

```


```{r Pregunta 8: k-means}

#Preparamos el dataset con valores númericos

#Eliminamos NA de la columna Size 
df$Size[is.na(df$Size)] <- 0

#Obtenemos el número de carácteres del recurso y reordenamos
df$ResourceLength <- nchar(df$Resource)
df <- df %>% select(1:5,ResourceLength,6:ncol(df))

#Convertimos la fecha y hora a número y reordenamos
df$NumericDate <- as.numeric(df$Date)
df <- df %>% select(1:2,NumericDate,3:ncol(df))

# Seleccionamos las columnas númericas y factores
df_kmeans <- df[, c("NumericDate", "RequestType","ResourceType","ResourceLength","Protocol","Version","StatusCode","Size")]

#Convertimos los factores a números eliminando NA
df_kmeans_one_hot <- one_hot(as.data.table(df_kmeans), sparsifyNAs = TRUE)


# Llamamos a la función kmeans
set.seed(2025)  

# Se aplica el algoritmo k-means con 3 y 6 clusters, con 25 iteraciones
resultado_kmeans_3 <- kmeans(df_kmeans_one_hot, centers = 3, iter.max=1000, nstart = 25)
resultado_kmeans_6 <- kmeans(df_kmeans_one_hot, centers = 6, iter.max=1000, nstart = 25)

# Se agregan los clusters al dataframe con los valores númericos
df_kmeans_one_hot$Cluster3 <- as.factor(resultado_kmeans_3$cluster)
df_kmeans_one_hot$Cluster6 <- as.factor(resultado_kmeans_6$cluster)

# Se crean los dos gráficos
ggplot(df_kmeans_one_hot,aes(x = NumericDate, y = ResourceLength, color = Cluster3)) +
  geom_point(size = 1, alpha = 0.1) +
  labs(title = "K-Means con 3 subgrupos",
       x = "Fecha Númerica",
       y = "Longitud del recurso",
       color = "Cluster") +
  theme_minimal() 

ggplot(df_kmeans_one_hot, aes(x = NumericDate, y = ResourceLength, color = Cluster6)) +
  geom_point(size = 1, alpha = 0.1) +
  labs(title = "K-Means con 6 subgrupos",
       x = "Fecha Númerica",
       y = "Longitud del recurso",
       color = "Cluster") +
  theme_minimal()


```


Justificación del Análisis de Clústers:


En este caso, utilizamos el algoritmo k-means para segmentar las peticiones en función de dos variables relevantes, la "Fecha numérica" (que corresponde a la hora de la petición) y el "Tamaño de la respuesta" (en bytes).

1. Resultados gráficos:


-> Con 3 clústers: La segmentación nos produce 3 patrones generales:

-> Clúster 1: peticiones con respuestas grandes, probablemente archivos multimedia o de descarga pesada, en situaciones de alta demanda.

-> Clúster 2: peticiones con respuestas más pequeñas, habituales de archivos estáticos o comunes, en intervalos de baja demanda.

-> Clúster 3: peticiones fuera del uso habitual, errores, recursos con tamaños mínimos o códigos de estado directamente relacionados (404, 500).

-> Con 6 clústers: al dividir las peticiones en más grupos, se produce una segmentación más detalla, con la que somos capaces de detectar picos de actividad de menor envergadura y variaciones en el tamaño de las respuestas que mediante una menor cantidad de clústers serían difíciles de observar.

2. Justificación sobre la elección de k:


Utilizar 3 clústers nos da una información general pautas más amplias (por ejemplo, solicitudes grandes frente a pequeñas) mientras que con 6 clústers seremos capaces de llegar a una segmentación más adecuada, a la captación de variaciones más sutiles, y a una información más detallada de las peticiones.

3. Conclusiones:


La aplicación de k-means con diferentes k nos permite capturar la información relativa a las pautas generales y al mismo tiempo variaciones de las peticiones si usamos 3 clústers para la información más general y hasta 6 clústers para la más concreta, lo que nos parece esencial para mejorar la comprensión de las peticiones en conjuntos de datos de gran tamaño. 



